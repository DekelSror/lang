Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    bool
    else
    has
    is
    literal
    logic_op
    loop
    run
    usertype

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt
Rule 2     program -> program stmt
Rule 3     stmt -> stmt newline
Rule 4     stmt -> expr initialize expr
Rule 5     stmt -> if expr stmt
Rule 6     stmt -> fn name ( params ) rv_type name { stmt }
Rule 7     params -> <empty>
Rule 8     params -> expr expr
Rule 9     params -> params , expr expr
Rule 10    expr -> name
Rule 11    expr -> number
Rule 12    expr -> string
Rule 13    expr -> name ( commas )
Rule 14    expr -> expr compare_op expr
Rule 15    expr -> expr arith_op expr
Rule 16    commas -> <empty>
Rule 17    commas -> expr
Rule 18    commas -> commas , expr

Terminals, with rules where they appear

(                    : 6 13
)                    : 6 13
,                    : 9 18
arith_op             : 15
bool                 : 
compare_op           : 14
else                 : 
error                : 
fn                   : 6
has                  : 
if                   : 5
initialize           : 4
is                   : 
literal              : 
logic_op             : 
loop                 : 
name                 : 6 6 10 13
newline              : 3
number               : 11
run                  : 
rv_type              : 6
string               : 12
usertype             : 
{                    : 6
}                    : 6

Nonterminals, with rules where they appear

commas               : 13 18
expr                 : 4 4 5 8 8 9 9 14 14 15 15 17 18
params               : 6 9
program              : 2 0
stmt                 : 1 2 3 5 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt
    (2) program -> . program stmt
    (3) stmt -> . stmt newline
    (4) stmt -> . expr initialize expr
    (5) stmt -> . if expr stmt
    (6) stmt -> . fn name ( params ) rv_type name { stmt }
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    if              shift and go to state 4
    fn              shift and go to state 5
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    program                        shift and go to state 1
    stmt                           shift and go to state 2
    expr                           shift and go to state 3

state 1

    (0) S' -> program .
    (2) program -> program . stmt
    (3) stmt -> . stmt newline
    (4) stmt -> . expr initialize expr
    (5) stmt -> . if expr stmt
    (6) stmt -> . fn name ( params ) rv_type name { stmt }
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    if              shift and go to state 4
    fn              shift and go to state 5
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    stmt                           shift and go to state 9
    expr                           shift and go to state 3

state 2

    (1) program -> stmt .
    (3) stmt -> stmt . newline

    if              reduce using rule 1 (program -> stmt .)
    fn              reduce using rule 1 (program -> stmt .)
    name            reduce using rule 1 (program -> stmt .)
    number          reduce using rule 1 (program -> stmt .)
    string          reduce using rule 1 (program -> stmt .)
    $end            reduce using rule 1 (program -> stmt .)
    newline         shift and go to state 10


state 3

    (4) stmt -> expr . initialize expr
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    initialize      shift and go to state 11
    compare_op      shift and go to state 12
    arith_op        shift and go to state 13


state 4

    (5) stmt -> if . expr stmt
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 14

state 5

    (6) stmt -> fn . name ( params ) rv_type name { stmt }

    name            shift and go to state 15


state 6

    (10) expr -> name .
    (13) expr -> name . ( commas )

    initialize      reduce using rule 10 (expr -> name .)
    compare_op      reduce using rule 10 (expr -> name .)
    arith_op        reduce using rule 10 (expr -> name .)
    if              reduce using rule 10 (expr -> name .)
    fn              reduce using rule 10 (expr -> name .)
    name            reduce using rule 10 (expr -> name .)
    number          reduce using rule 10 (expr -> name .)
    string          reduce using rule 10 (expr -> name .)
    newline         reduce using rule 10 (expr -> name .)
    $end            reduce using rule 10 (expr -> name .)
    }               reduce using rule 10 (expr -> name .)
    )               reduce using rule 10 (expr -> name .)
    ,               reduce using rule 10 (expr -> name .)
    (               shift and go to state 16


state 7

    (11) expr -> number .

    initialize      reduce using rule 11 (expr -> number .)
    compare_op      reduce using rule 11 (expr -> number .)
    arith_op        reduce using rule 11 (expr -> number .)
    if              reduce using rule 11 (expr -> number .)
    fn              reduce using rule 11 (expr -> number .)
    name            reduce using rule 11 (expr -> number .)
    number          reduce using rule 11 (expr -> number .)
    string          reduce using rule 11 (expr -> number .)
    newline         reduce using rule 11 (expr -> number .)
    $end            reduce using rule 11 (expr -> number .)
    }               reduce using rule 11 (expr -> number .)
    )               reduce using rule 11 (expr -> number .)
    ,               reduce using rule 11 (expr -> number .)


state 8

    (12) expr -> string .

    initialize      reduce using rule 12 (expr -> string .)
    compare_op      reduce using rule 12 (expr -> string .)
    arith_op        reduce using rule 12 (expr -> string .)
    if              reduce using rule 12 (expr -> string .)
    fn              reduce using rule 12 (expr -> string .)
    name            reduce using rule 12 (expr -> string .)
    number          reduce using rule 12 (expr -> string .)
    string          reduce using rule 12 (expr -> string .)
    newline         reduce using rule 12 (expr -> string .)
    $end            reduce using rule 12 (expr -> string .)
    }               reduce using rule 12 (expr -> string .)
    )               reduce using rule 12 (expr -> string .)
    ,               reduce using rule 12 (expr -> string .)


state 9

    (2) program -> program stmt .
    (3) stmt -> stmt . newline

    if              reduce using rule 2 (program -> program stmt .)
    fn              reduce using rule 2 (program -> program stmt .)
    name            reduce using rule 2 (program -> program stmt .)
    number          reduce using rule 2 (program -> program stmt .)
    string          reduce using rule 2 (program -> program stmt .)
    $end            reduce using rule 2 (program -> program stmt .)
    newline         shift and go to state 10


state 10

    (3) stmt -> stmt newline .

    newline         reduce using rule 3 (stmt -> stmt newline .)
    if              reduce using rule 3 (stmt -> stmt newline .)
    fn              reduce using rule 3 (stmt -> stmt newline .)
    name            reduce using rule 3 (stmt -> stmt newline .)
    number          reduce using rule 3 (stmt -> stmt newline .)
    string          reduce using rule 3 (stmt -> stmt newline .)
    $end            reduce using rule 3 (stmt -> stmt newline .)
    }               reduce using rule 3 (stmt -> stmt newline .)


state 11

    (4) stmt -> expr initialize . expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 17

state 12

    (14) expr -> expr compare_op . expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 18

state 13

    (15) expr -> expr arith_op . expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 19

state 14

    (5) stmt -> if expr . stmt
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr
    (3) stmt -> . stmt newline
    (4) stmt -> . expr initialize expr
    (5) stmt -> . if expr stmt
    (6) stmt -> . fn name ( params ) rv_type name { stmt }
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    compare_op      shift and go to state 12
    arith_op        shift and go to state 13
    if              shift and go to state 4
    fn              shift and go to state 5
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 3
    stmt                           shift and go to state 20

state 15

    (6) stmt -> fn name . ( params ) rv_type name { stmt }

    (               shift and go to state 21


state 16

    (13) expr -> name ( . commas )
    (16) commas -> .
    (17) commas -> . expr
    (18) commas -> . commas , expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    )               reduce using rule 16 (commas -> .)
    ,               reduce using rule 16 (commas -> .)
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    commas                         shift and go to state 22
    expr                           shift and go to state 23

state 17

    (4) stmt -> expr initialize expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    newline         reduce using rule 4 (stmt -> expr initialize expr .)
    if              reduce using rule 4 (stmt -> expr initialize expr .)
    fn              reduce using rule 4 (stmt -> expr initialize expr .)
    name            reduce using rule 4 (stmt -> expr initialize expr .)
    number          reduce using rule 4 (stmt -> expr initialize expr .)
    string          reduce using rule 4 (stmt -> expr initialize expr .)
    $end            reduce using rule 4 (stmt -> expr initialize expr .)
    }               reduce using rule 4 (stmt -> expr initialize expr .)
    compare_op      shift and go to state 12
    arith_op        shift and go to state 13


state 18

    (14) expr -> expr compare_op expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    initialize      reduce using rule 14 (expr -> expr compare_op expr .)
    compare_op      reduce using rule 14 (expr -> expr compare_op expr .)
    arith_op        reduce using rule 14 (expr -> expr compare_op expr .)
    if              reduce using rule 14 (expr -> expr compare_op expr .)
    fn              reduce using rule 14 (expr -> expr compare_op expr .)
    name            reduce using rule 14 (expr -> expr compare_op expr .)
    number          reduce using rule 14 (expr -> expr compare_op expr .)
    string          reduce using rule 14 (expr -> expr compare_op expr .)
    newline         reduce using rule 14 (expr -> expr compare_op expr .)
    $end            reduce using rule 14 (expr -> expr compare_op expr .)
    }               reduce using rule 14 (expr -> expr compare_op expr .)
    )               reduce using rule 14 (expr -> expr compare_op expr .)
    ,               reduce using rule 14 (expr -> expr compare_op expr .)

  ! compare_op      [ shift and go to state 12 ]
  ! arith_op        [ shift and go to state 13 ]


state 19

    (15) expr -> expr arith_op expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    initialize      reduce using rule 15 (expr -> expr arith_op expr .)
    arith_op        reduce using rule 15 (expr -> expr arith_op expr .)
    if              reduce using rule 15 (expr -> expr arith_op expr .)
    fn              reduce using rule 15 (expr -> expr arith_op expr .)
    name            reduce using rule 15 (expr -> expr arith_op expr .)
    number          reduce using rule 15 (expr -> expr arith_op expr .)
    string          reduce using rule 15 (expr -> expr arith_op expr .)
    newline         reduce using rule 15 (expr -> expr arith_op expr .)
    $end            reduce using rule 15 (expr -> expr arith_op expr .)
    }               reduce using rule 15 (expr -> expr arith_op expr .)
    )               reduce using rule 15 (expr -> expr arith_op expr .)
    ,               reduce using rule 15 (expr -> expr arith_op expr .)
    compare_op      shift and go to state 12

  ! compare_op      [ reduce using rule 15 (expr -> expr arith_op expr .) ]
  ! arith_op        [ shift and go to state 13 ]


state 20

    (5) stmt -> if expr stmt .
    (3) stmt -> stmt . newline

  ! shift/reduce conflict for newline resolved as shift
    if              reduce using rule 5 (stmt -> if expr stmt .)
    fn              reduce using rule 5 (stmt -> if expr stmt .)
    name            reduce using rule 5 (stmt -> if expr stmt .)
    number          reduce using rule 5 (stmt -> if expr stmt .)
    string          reduce using rule 5 (stmt -> if expr stmt .)
    $end            reduce using rule 5 (stmt -> if expr stmt .)
    }               reduce using rule 5 (stmt -> if expr stmt .)
    newline         shift and go to state 10

  ! newline         [ reduce using rule 5 (stmt -> if expr stmt .) ]


state 21

    (6) stmt -> fn name ( . params ) rv_type name { stmt }
    (7) params -> .
    (8) params -> . expr expr
    (9) params -> . params , expr expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    )               reduce using rule 7 (params -> .)
    ,               reduce using rule 7 (params -> .)
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    params                         shift and go to state 24
    expr                           shift and go to state 25

state 22

    (13) expr -> name ( commas . )
    (18) commas -> commas . , expr

    )               shift and go to state 26
    ,               shift and go to state 27


state 23

    (17) commas -> expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    )               reduce using rule 17 (commas -> expr .)
    ,               reduce using rule 17 (commas -> expr .)
    compare_op      shift and go to state 12
    arith_op        shift and go to state 13


state 24

    (6) stmt -> fn name ( params . ) rv_type name { stmt }
    (9) params -> params . , expr expr

    )               shift and go to state 28
    ,               shift and go to state 29


state 25

    (8) params -> expr . expr
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    compare_op      shift and go to state 12
    arith_op        shift and go to state 13
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 30

state 26

    (13) expr -> name ( commas ) .

    initialize      reduce using rule 13 (expr -> name ( commas ) .)
    compare_op      reduce using rule 13 (expr -> name ( commas ) .)
    arith_op        reduce using rule 13 (expr -> name ( commas ) .)
    if              reduce using rule 13 (expr -> name ( commas ) .)
    fn              reduce using rule 13 (expr -> name ( commas ) .)
    name            reduce using rule 13 (expr -> name ( commas ) .)
    number          reduce using rule 13 (expr -> name ( commas ) .)
    string          reduce using rule 13 (expr -> name ( commas ) .)
    newline         reduce using rule 13 (expr -> name ( commas ) .)
    $end            reduce using rule 13 (expr -> name ( commas ) .)
    }               reduce using rule 13 (expr -> name ( commas ) .)
    )               reduce using rule 13 (expr -> name ( commas ) .)
    ,               reduce using rule 13 (expr -> name ( commas ) .)


state 27

    (18) commas -> commas , . expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 31

state 28

    (6) stmt -> fn name ( params ) . rv_type name { stmt }

    rv_type         shift and go to state 32


state 29

    (9) params -> params , . expr expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 33

state 30

    (8) params -> expr expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    )               reduce using rule 8 (params -> expr expr .)
    ,               reduce using rule 8 (params -> expr expr .)
    compare_op      shift and go to state 12
    arith_op        shift and go to state 13


state 31

    (18) commas -> commas , expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    )               reduce using rule 18 (commas -> commas , expr .)
    ,               reduce using rule 18 (commas -> commas , expr .)
    compare_op      shift and go to state 12
    arith_op        shift and go to state 13


state 32

    (6) stmt -> fn name ( params ) rv_type . name { stmt }

    name            shift and go to state 34


state 33

    (9) params -> params , expr . expr
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    compare_op      shift and go to state 12
    arith_op        shift and go to state 13
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    expr                           shift and go to state 35

state 34

    (6) stmt -> fn name ( params ) rv_type name . { stmt }

    {               shift and go to state 36


state 35

    (9) params -> params , expr expr .
    (14) expr -> expr . compare_op expr
    (15) expr -> expr . arith_op expr

    )               reduce using rule 9 (params -> params , expr expr .)
    ,               reduce using rule 9 (params -> params , expr expr .)
    compare_op      shift and go to state 12
    arith_op        shift and go to state 13


state 36

    (6) stmt -> fn name ( params ) rv_type name { . stmt }
    (3) stmt -> . stmt newline
    (4) stmt -> . expr initialize expr
    (5) stmt -> . if expr stmt
    (6) stmt -> . fn name ( params ) rv_type name { stmt }
    (10) expr -> . name
    (11) expr -> . number
    (12) expr -> . string
    (13) expr -> . name ( commas )
    (14) expr -> . expr compare_op expr
    (15) expr -> . expr arith_op expr

    if              shift and go to state 4
    fn              shift and go to state 5
    name            shift and go to state 6
    number          shift and go to state 7
    string          shift and go to state 8

    stmt                           shift and go to state 37
    expr                           shift and go to state 3

state 37

    (6) stmt -> fn name ( params ) rv_type name { stmt . }
    (3) stmt -> stmt . newline

    }               shift and go to state 38
    newline         shift and go to state 10


state 38

    (6) stmt -> fn name ( params ) rv_type name { stmt } .

    newline         reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    if              reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    fn              reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    name            reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    number          reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    string          reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    $end            reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)
    }               reduce using rule 6 (stmt -> fn name ( params ) rv_type name { stmt } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for newline in state 20 resolved as shift
